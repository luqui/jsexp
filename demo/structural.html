<html>
 <head>
  <script src="jquery.min.js"></script>
  <script src="../StructuralFramework.js"></script>
  <script src="../StructuralEditor.js"></script>
  <script src="../StructuralGrammar.js"></script>

  <style>
   .eatom { color: red }
   .selected { background: #fdd }
   .box { background: lightgreen }
   .unparsed { opacity: 0.5 }
   .cursor_selected { border-left: 1px solid blue }
   .cursor_selected_right { border-right: 1px solid blue }
   .modeline { font-weight: bold }
   .indented { margin-left: 4em }
  </style>

  <script>

// main : jQuery * StructuralFramework * (top_node -> StructuralEditor) -> Module
var main = function($, SF, SG, SE) {

// CodeCatalog Snippet http://www.codecatalog.net/323/2/
var for_kv = function(object, body) {
    for (var k in object) {
        if (object.hasOwnProperty(k)) {
            body(k, object[k]);
        }
    }
};
// End CodeCatalog Snippet


// CodeCatalog Snippet http://www.codecatalog.net/378/2/
var regexp_tokenizer = function(tokens) { 
    return function(str) {
        var bestMatch = null;
        var bestFunc = null; 
        for_kv(tokens, function(k,v) {
            var m = new RegExp('^' + k)(str);
            if (m && (!bestMatch || m[0].length > bestMatch[0].length)) {
                bestMatch = m;
                bestFunc = v;
            }
        });

        // don't match the whole string in case we are in the middle of typing a token
        // we use \0 to mean "eof" so this will pass.
        if (bestFunc && bestMatch[0].length < str.length) {
            return [bestFunc(bestMatch), str.slice(bestMatch[0].length)];
        }
        else {
            return null;
        }
    }
};
// End CodeCatalog Snippet

// CodeCatalog Snippet http://www.codecatalog.net/256/1/
var text_node = function(text) { return document.createTextNode(text) };
// End CodeCatalog Snippet

// CodeCatalog Snippet http://www.codecatalog.net/16/3/
var elt = function(name, attrs) {
    var r = $(document.createElement(name));
    if (attrs) {
        for (var i in attrs) {
            r.attr(i, attrs[i]);
        }
    }
    for (var i = 2; i < arguments.length; ++i) {
        r.append(arguments[i]);
    }
    return r;
};
// End CodeCatalog Snippet

var space = SG.token(/\s*/, ' ');

var top_class = SG.grammar('stmts', {
    'stmts': SG.choice(
        SG.empty,
        SG.seq(SG.sym('stmt'), SG.token(/;/, ';\n'), SG.indent(SG.sym('stmts')))),
    'stmt': SG.choice(
        SG.sym('var_decl'),
        SG.sym('funcall')),
    'var_decl': SG.seq(SG.literal('var'), space, SG.sym('identifier')),
    'funcall': SG.seq(SG.sym('identifier'), SG.literal('('), SG.sym('expr'), SG.literal(')')),
    'identifier': SG.token(/[a-zA-Z_$][\w$]*/),
    'expr': SG.sym('identifier')
});

var top_node  = top_class.open();
var editor = SE(top_node, $(document));

$(document.body).append(editor);

};


jQuery(function() {
    var SF = StructuralFramework(jQuery);
    var SG = StructuralGrammar(SF);
    main(
        jQuery, 
        SF,
        SG,
        function(top_node, event_node) { 
            return StructuralEditor(jQuery, SF, top_node, event_node) 
        }
    );
});


  </script>
 </head>
 <body>
 </body>
</html>
