<html>
<head> 
<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
<script src="codemirror.js"></script>
<link rel="stylesheet" href="codemirror.css" />

<style>
span.space { background: lightgray }
span.word { background: pink }
span.indent { background: lightblue }
span.other { }
</style>

<script>
$(function() { 

// CodeCatalog Snippet http://www.codecatalog.net/341/1/
var split_lines = function(str) {
    return str.split(/\n/);
};
// End CodeCatalog Snippet

var magicTokenMode = function(options) {
    var startState = options.startState || function() { return null };
    var copyState = function(s) { return CodeMirror.copyState(options, s) };
    
    return {
        startState: function() {
            return { linepart: 0, token: null, state: (options.startState || function() { return null })() }
        },
        copyState: function(state) {
            return { linepart: state.linepart, token: state.token, state: copyState(state.state) }
        },
        token: function(stream, state) {
            if (state.linepart != 0 && stream.sol()) {
                var toklines = split_lines(state.token.text);
                if (stream.match(toklines[state.linepart])) {
                    if (state.linepart < toklines.length && stream.eol()) {
                        state.linepart += 1;
                    }
                    else { 
                        state.linepart = 0;
                    }
                }
                return state.token['class'];
            }

            var tok = options.token(stream, state.state);
            if (tok === null || tok === undefined) {
                return state.token = null;
            }
            if (typeof(tok) === 'string') {
                state.token = { 'class': tok };
                return tok;
            }
            if (typeof(tok) === 'object') {
                state.token = tok;
                if (typeof(tok.text) === 'string') {
                    var toklines = split_lines(tok.text);
                    if (stream.match(toklines[0])) {
                        if (stream.eol() && toklines.length > 1) { state.linepart = 1; }
                    }
                }
                return tok['class'];
            }
            throw "Bad return value from token: " + tok;
        },
        onChange: function(mirror, change) {
            var mtok = mirror.getTokenAt({ line: change.from.line, ch: change.from.ch + change.text[0].length });
            if (!mtok) return;
            
            var focusmtok = null;
            var focusline = null;
            var enterkey = false;
            if (change.text.length == 2 && change.text[0] === '' && change.text[1] === '') {  // enter key
                enterkey = true;
                focusline = change.from.line;
                focusmtok = mirror.getTokenAt({ line: focusline });
            }
            else if (change.text[0].length > 0 && change.from.ch == mtok.start && change.from.ch > 0) {  // start of new token
                focusline = change.from.line;
                focusmtok = mirror.getTokenAt({ line: focusline, ch: change.from.ch });
            }

            if (focusmtok) {
                var tok = focusmtok.state.token;
                if (tok && typeof(tok.text) === 'string' && focusmtok.string !== tok.text) {
                    var to = { line: focusline, ch: focusmtok.end };
                    if (enterkey && /\n/(tok.text)) { to = { line: focusline+1, ch: 0 } }
                    mirror.replaceRange(tok.text, { line: focusline, ch: focusmtok.start }, to);
                }
            }
        },
    }
};

var alty = magicTokenMode({
    token: function(stream, state) {
        var sol = stream.sol();
        if (stream.eol()) {
            return { 'class': 'space', 'text': '\n    ' };
        }
        if (stream.match(/^\s+/)) {
            return !sol ? { 'class': 'space', text: ' ' } : { 'class': 'space' };
        }
        if (stream.match(/^\w+/)) {
            return { 'class': 'word', text: 'word' };
        }
        if (stream.match(/^:/)) {
            return { 'class': 'indent', text: ':\n    ' };
        }
        stream.eatWhile(/^.*/);
        return 'other';
    }
});

CodeMirror.defineMode("alty", function(conifg, parserConfig) {
    return alty;
});

mirror = CodeMirror(document.body, {
    onChange: alty.onChange,
    enterMode: 'flat'
});

});
</script>  
</head>
<body>
</body>
</html>
